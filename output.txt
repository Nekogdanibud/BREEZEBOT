=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT ===

üìÑ –§–ê–ô–õ: /home/REMBOT/.env
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
REMNAWAVE_BASE_URL=https://panel.breezeway.su:8443
REMNAWAVE_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1dWlkIjoiM2EzMDUzZjktMWZlOS00ZGJmLWIxNzgtMzdiNDdhNDI1NzBlIiwidXNlcm5hbWUiOm51bGwsInJvbGUiOiJBUEkiLCJpYXQiOjE3NDc3NDQ1NjYsImV4cCI6MTAzODc2NTgxNjZ9.whhKfGrb5jm1htnITSyHM9zi0jz5is36Lq7m5ktnm6s
REMNAWAVE_ADMIN_USERNAME=nekogdanibud
REMNAWAVE_ADMIN_PASSWORD=Powered.Mill274327432743
REMNAWAVE_INBOUND_UUID=0e69eb21-28d8-46d7-aa57-44ee45b14ff5
REMNAWAVE_USER_UUID=d63c36c9-8fc9-4cb0-82fb-1903e4125e8e
REMNAWAVE_SHORT_UUID=q9ESpAJta1tNHb2Z

BOT_TOKEN=8002740582:AAFggmFGUNRIf7mRYFu4zVKnp5imQUPh1Qk

# PostgreSQL Database
DATABASE_URL=postgresql+asyncpg://remnawave_usr:PowMill2743@85.192.48.12:5432/bot



--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/.gitignore
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏ —Å–∫—Ä—ã—Ç—ã–µ .env —Ñ–∞–π–ª—ã
env/
venv/
.venv/
.env
.env.local
.env.*
!.env.example

# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—ç—à Python
__pycache__/
*.py[cod]
*$py.class

# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª—ã –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
*.egg-info/
*.egg
dist/
build/

# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª—ã IDE
.idea/
.vscode/
*.swp
*.swo

# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
*.log
*.tmp
*.bak

# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –û–° —Ñ–∞–π–ª—ã
.DS_Store
Thumbs.db


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/.env.example
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
REMNAWAVE_BASE_URL=
REMNAWAVE_TOKEN=
REMNAWAVE_ADMIN_USERNAME=
REMNAWAVE_ADMIN_PASSWORD=

BOT_TOKEN=

# PostgreSQL Database
DATABASE_URL=postgresql+asyncpg://user:pass@localhost:5432/dbname



--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/output.txt
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/README.md
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
# BREEZEBOT


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/main.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
import asyncio
import logging
import os
from dotenv import load_dotenv

from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

from core.middleware import RoleMiddleware
from core.database.model import Base
from core.database.database import async_session, engine

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ –¥–ª—è SQLAlchemy
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.DEBUG)
load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

async def main():
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
    if not (BOT_TOKEN := os.getenv("BOT_TOKEN")) or not (DATABASE_URL := os.getenv("DATABASE_URL")):
        logger.error("–¢—Ä–µ–±—É–µ–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!")
        return

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
    bot = Bot(token=BOT_TOKEN)
    dp = Dispatcher(storage=MemoryStorage())
    
    # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ —Å–µ—Å—Å–∏–π
    session_pool = async_sessionmaker(
        bind=engine,
        expire_on_commit=False,
        class_=AsyncSession
    )

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è middleware
    dp.update.outer_middleware(RoleMiddleware(session_pool=session_pool))

    # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ä–æ—É—Ç–µ—Ä–æ–≤
    from modules.common.router import main_menu_router
    dp.include_router(main_menu_router)

    try:
        logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
        await dp.start_polling(bot)
    finally:
        await engine.dispose()
        logger.info("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î –∑–∞–∫—Ä—ã—Ç—ã")

if __name__ == "__main__":
    asyncio.run(main())


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules ===

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/admin ===

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/admin/mailing ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/mailing/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/mailing/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/mailing/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/mailing/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/admin/user_list ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/user_list/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/user_list/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/user_list/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/user_list/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/admin/main_menu ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/main_menu/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/main_menu/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/main_menu/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/admin/main_menu/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/common ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/common/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import Router, F
from aiogram.filters import Command
from .handlers import start_command
from core.filters import IsNotBanned
from modules.user.profile.router import profile_router
from modules.user.subscription.router import subscriptions_router
from modules.user.control_subscription.router import router as control_subscription_router
from .texts import MAIN_MENU_CALLBACK

main_menu_router = Router()
main_menu_router.callback_query.filter(IsNotBanned)
main_menu_router.include_router(profile_router)
main_menu_router.include_router(subscriptions_router)
main_menu_router.include_router(control_subscription_router)
# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start
main_menu_router.message.register(
    start_command,
    Command("start"),
    IsNotBanned
)
main_menu_router.callback_query.register(
    start_command,
    F.data == MAIN_MENU_CALLBACK,
    IsNotBanned
)



--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/common/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import F
from aiogram.types import Message, CallbackQuery
from .texts import MAIN_MENU_TEXT
from .keyboards import get_main_menu
from typing import Union
import logging

logger = logging.getLogger(__name__)

async def start_command(event: Union[Message, CallbackQuery], role: str):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    try:
        if isinstance(event, Message):
            # –î–ª—è –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            await event.answer(
                text=MAIN_MENU_TEXT,
                reply_markup=get_main_menu(role)
            )
        else:
            # –î–ª—è callback-–∑–∞–ø—Ä–æ—Å–æ–≤
            await event.message.edit_text(
                text=MAIN_MENU_TEXT,
                reply_markup=get_main_menu(role)
            )
            await event.answer()  # –£–±–∏—Ä–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ start_command: {str(e)}")
        if isinstance(event, CallbackQuery):
            await event.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–Ω—é", show_alert=True)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/common/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
MAIN_MENU_TEXT = "üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é! –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:"

# –¢–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫
PROFILE_BUTTON = "üë§ –ü—Ä–æ—Ñ–∏–ª—å"
SUBSCRIPTION_BUTTON = "üíé –ü–æ–¥–ø–∏—Å–∫–∞"
HELP_BUTTON = "‚ùì –ü–æ–º–æ—â—å"
SUPPORT_BUTTON = "üõé –ü–æ–¥–¥–µ—Ä–∂–∫–∞"
ADMIN_BUTTON = "üëë –ê–¥–º–∏–Ω-—Ü–µ–Ω—Ç—Ä"

# Callback data
MAIN_MENU_CALLBACK = "menu:main"
PROFILE_CALLBACK = "menu:profile"
SUBSCRIPTION_CALLBACK = "subscriptions"
HELP_CALLBACK = "menu:help"
SUPPORT_CALLBACK = "menu:support"
ADMIN_CALLBACK = "menu:admin"


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/common/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton
from .texts import (
    PROFILE_BUTTON, SUBSCRIPTION_BUTTON, HELP_BUTTON,
    SUPPORT_BUTTON, ADMIN_BUTTON,
    PROFILE_CALLBACK, SUBSCRIPTION_CALLBACK, HELP_CALLBACK,
    SUPPORT_CALLBACK, ADMIN_CALLBACK
)

def get_main_menu(role: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞
    builder.button(text=PROFILE_BUTTON, callback_data=PROFILE_CALLBACK)
    builder.button(text=SUBSCRIPTION_BUTTON, callback_data=SUBSCRIPTION_CALLBACK)
    
    # –ö–Ω–æ–ø–∫–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
    special_buttons = []
    if role == "SUPPORT":
        special_buttons.append((SUPPORT_BUTTON, SUPPORT_CALLBACK))
    elif role == "ADMIN":
        special_buttons.extend([
            (SUPPORT_BUTTON, SUPPORT_CALLBACK),
            (ADMIN_BUTTON, ADMIN_CALLBACK)
        ])
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    for text, callback in special_buttons:
        builder.button(text=text, callback_data=callback)
    
    # –ö–Ω–æ–ø–∫–∞ –ø–æ–º–æ—â–∏ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º —Ä—è–¥—É
    builder.button(text=HELP_BUTTON, callback_data=HELP_CALLBACK)
    
    # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–æ–∫: 
    # 1-–π —Ä—è–¥: 2 –∫–Ω–æ–ø–∫–∏, 2-–π —Ä—è–¥: —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏, 3-–π —Ä—è–¥: 1 –∫–Ω–æ–ø–∫–∞
    builder.adjust(2, *[2]*len(special_buttons), 1)
    
    return builder.as_markup()


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/common/callbacks.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
# modules/common/callbacks.py
from aiogram.filters.callback_data import CallbackData

class ProfileActions(CallbackData, prefix="profile"):
    action: str  # refresh, manage_vpn, etc.


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/user ===

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/user/profile ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/profile/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import Router, F
from .handlers import show_profile
from modules.common.texts import PROFILE_CALLBACK

profile_router = Router()

profile_router.callback_query.register(
    show_profile,
    F.data.startswith(PROFILE_CALLBACK)
)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/profile/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import F
from aiogram.types import CallbackQuery
from aiogram.exceptions import TelegramBadRequest
from core.database.crud import get_user_full_data
from .texts import PROFILE_TEXT
from .keyboards import get_profile_kb
from core.database.database import async_session
import logging
from datetime import datetime
from core.database.model import User

logger = logging.getLogger(__name__)

async def show_profile(callback: CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–∫–∞–∑–∞ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –¥–∞–Ω–Ω—ã–º–∏ —Ç–æ–ª—å–∫–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î"""
    try:
        await callback.answer()

        async with async_session() as session:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î
            user_data = await get_user_full_data(session, callback.from_user.id)
            
            if not user_data or not isinstance(user_data.get("user"), User):
                return await callback.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è", show_alert=True)
            
            user = user_data["user"]
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–æ—Ñ–∏–ª—è
            profile_text = PROFILE_TEXT.format(
                username=f"@{user.username}" if user.username else "–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                balance=float(user.balance) if user.balance else 0.0,
                subscriptions_count=user_data.get("subscriptions_count", 0)
            )
            
            try:
                await callback.message.edit_text(
                    text=profile_text,
                    reply_markup=get_profile_kb()
                )
            except TelegramBadRequest:
                # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                pass
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ show_profile: {str(e)}", exc_info=True)
        await callback.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–æ—Ñ–∏–ª—è", show_alert=True)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/profile/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
PROFILE_TEXT = """
üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å*

‚ñ´Ô∏è *–ù–∏–∫–Ω–µ–π–º:* {username}
‚ñ´Ô∏è *–ë–∞–ª–∞–Ω—Å:* {balance} ‚ÇΩ
‚ñ´Ô∏è *–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫:* {subscriptions_count}
"""

BACK_BUTTON = "üîô –ù–∞–∑–∞–¥"


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/profile/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton
from .texts import BACK_BUTTON
from modules.common.texts import MAIN_MENU_CALLBACK

def get_profile_kb() -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.button(text=BACK_BUTTON, callback_data=MAIN_MENU_CALLBACK)
    return builder.as_markup()


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/user/control_subscription ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/control_subscription/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import Router, F  
from aiogram.types import CallbackQuery, Message  
from core.filters import IsNotBanned  
from .handlers import (  
    manage_subscription_menu,  
    renew_subscription,  
    view_devices,  
    show_device_details,  
    remove_device_callback,  
    initiate_transfer_subscription,  
    process_transfer_contact,  
    cancel_transfer,  
    TransferSubscriptionStates  
)  

router = Router()  

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–æ–π  
router.callback_query.register(  
    manage_subscription_menu,  
    F.data.startswith("manage_subscription:"),  
    IsNotBanned  
)  

router.callback_query.register(  
    renew_subscription,  
    F.data.startswith("renew_subscription:"),  
    IsNotBanned  
)  

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏  
router.callback_query.register(  
    view_devices,  
    F.data.startswith("view_devices:"),  
    IsNotBanned  
)  

router.callback_query.register(  
    show_device_details,  
    F.data.startswith("device_details:"),  
    IsNotBanned  
)  

router.callback_query.register(  
    remove_device_callback,  
    F.data.startswith("remove_device:"),  
    IsNotBanned  
)  

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏  
router.callback_query.register(  
    initiate_transfer_subscription,  
    F.data.startswith("transfer_subscription:"),  
    IsNotBanned  
)  

router.callback_query.register(  
    cancel_transfer,  
    F.data.startswith("cancel_transfer:"),  
    IsNotBanned  
)  

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–Ω—Ç–∞–∫—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏  
router.message.register(  
    process_transfer_contact,  
    TransferSubscriptionStates.waiting_for_contact,  
    IsNotBanned  
)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/control_subscription/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from datetime import datetime, timedelta
from aiogram.types import CallbackQuery, Message, Contact
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from core.database import crud
from core.api.remnawave_client import remnawave_service
from core.database.database import async_session
from .keyboards import (
    get_manage_subscription_kb,
    get_device_list_kb,
    get_device_details_kb,
    get_cancel_transfer_kb,
    get_back_to_devices_kb,
    get_back_to_manage_kb,
    DEVICES_PER_PAGE
)
from .texts import (
    MANAGE_SUBSCRIPTION_TEXT,
    NO_SUBSCRIPTION_TEXT,
    INSUFFICIENT_BALANCE_TEXT,
    RENEWAL_PRICE_NOT_SET_TEXT,
    RENEW_SUBSCRIPTION_SUCCESS_TEXT,
    NO_DEVICES_TEXT,
    DEVICES_PAGINATION_TEXT,
    DEVICE_DETAILS_TEXT,
    LAST_DEVICE_TEXT,
    DEVICE_REMOVED_TEXT,
    TRANSFER_COOLDOWN_TEXT,
    TRANSFER_REQUEST_TEXT,
    INVALID_CONTACT_TEXT,
    SELF_TRANSFER_TEXT,
    TRANSFER_SUCCESS_TEXT,
    TRANSFER_RECIPIENT_NOTIFICATION_TEXT,
    TRANSFER_CANCELLED_TEXT,
    DEVICE_REMOVAL_LIMIT_TEXT,
    TRANSFER_LIMIT_WARNING,
    TRANSFER_COOLDOWN_DAYS,
    DEVICE_REMOVAL_LIMIT
)
import logging

logger = logging.getLogger(__name__)

class TransferSubscriptionStates(StatesGroup):
    waiting_for_contact = State()

async def manage_subscription_menu(callback: CallbackQuery) -> None:
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–æ–π"""
    try:
        await callback.answer()
        subscription_uuid = callback.data.split(":")[1]
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.answer(NO_SUBSCRIPTION_TEXT)
                return
            
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.answer("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
            
            sub_info = await remnawave_service.get_subscription_by_uuid(subscription_uuid)
            if "error" in sub_info:
                await callback.message.answer(f"–û—à–∏–±–∫–∞: {sub_info['error']}")
                return
            
            await callback.message.edit_text(
                MANAGE_SUBSCRIPTION_TEXT.format(
                    username=sub_info['username'],
                    used_traffic=sub_info['used_traffic_bytes'] / (1024 ** 3),
                    status=sub_info['status'].capitalize(),
                    renewal_price=float(local_sub.renewal_price) if local_sub.renewal_price else 0.0
                ),
                reply_markup=get_manage_subscription_kb(subscription_uuid),
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ manage_subscription_menu: {str(e)}", exc_info=True)
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω—é")

async def renew_subscription(callback: CallbackQuery) -> None:
    """–ü—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏"""
    try:
        await callback.answer()
        subscription_uuid = callback.data.split(":")[1]
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.answer(NO_SUBSCRIPTION_TEXT)
                return
                
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.answer("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
                
            user = await crud.get_user_by_telegram_id(session, callback.from_user.id)
            if not user:
                await callback.message.answer("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
                
            if local_sub.renewal_price is None:
                await callback.message.answer(RENEWAL_PRICE_NOT_SET_TEXT)
                return
                
            if user.balance < local_sub.renewal_price:
                await callback.message.answer(
                    INSUFFICIENT_BALANCE_TEXT.format(
                        required=local_sub.renewal_price,
                        balance=user.balance
                    ),
                    parse_mode="HTML"
                )
                return
                
            user.balance -= local_sub.renewal_price
            new_expiration = datetime.now() + timedelta(days=30)
            local_sub.expired_at = new_expiration
            await session.commit()
            
            await callback.message.answer(
                RENEW_SUBSCRIPTION_SUCCESS_TEXT.format(
                    expiration=new_expiration.strftime("%Y-%m-%d %H:%M:%S"),
                    amount=local_sub.renewal_price
                )
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ renew_subscription: {str(e)}", exc_info=True)
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏")

async def view_devices(callback: CallbackQuery) -> None:
    """–ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤"""
    try:
        await callback.answer()
        data = callback.data.split(":")
        subscription_uuid = data[1]
        page = int(data[2]) if len(data) > 2 else 0
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.answer(NO_SUBSCRIPTION_TEXT)
                return
                
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.answer("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
                
            devices = await remnawave_service.get_connected_devices(subscription_uuid)
            if not devices:
                await callback.message.answer(NO_DEVICES_TEXT)
                return
                
            sub_info = await remnawave_service.get_subscription_by_uuid(subscription_uuid)
            if "error" in sub_info:
                await callback.message.answer(f"–û—à–∏–±–∫–∞: {sub_info['error']}")
                return
                
            total_pages = (len(devices) + DEVICES_PER_PAGE - 1) // DEVICES_PER_PAGE
            paginated_devices = devices[page*DEVICES_PER_PAGE:(page+1)*DEVICES_PER_PAGE]
            
            await callback.message.edit_text(
                DEVICES_PAGINATION_TEXT.format(
                    username=sub_info['username'],
                    current_page=page+1,
                    total_pages=total_pages,
                    total_devices=len(devices)
                ),
                reply_markup=get_device_list_kb(
                    subscription_uuid,
                    paginated_devices,
                    page,
                    total_pages
                ),
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ view_devices: {str(e)}", exc_info=True)
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤")

async def show_device_details(callback: CallbackQuery) -> None:
    """–î–µ—Ç–∞–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
    try:
        await callback.answer()
        data = callback.data.split(":")
        subscription_uuid, short_hwid = data[1], data[2]
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.answer(NO_SUBSCRIPTION_TEXT)
                return
                
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.answer("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
                
            devices = await remnawave_service.get_connected_devices(subscription_uuid)
            device = next((d for d in devices if d['hwid'].startswith(short_hwid)), None)
            
            if not device:
                await callback.message.answer(NO_DEVICES_TEXT)
                return
                
            device_name = f"{device['platform']} {device['device_model']}".strip() or "Unknown"
            await callback.message.answer(
                DEVICE_DETAILS_TEXT.format(
                    hwid=device['hwid'],
                    name=device_name,
                    updated_at=device['updated_at']
                ),
                reply_markup=get_device_details_kb(subscription_uuid, device['hwid']),
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ show_device_details: {str(e)}", exc_info=True)
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")

async def remove_device_callback(callback: CallbackQuery) -> None:
    """–£–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è"""
    try:
        await callback.answer()
        data = callback.data.split(":")
        subscription_uuid, short_hwid = data[1], data[2]
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.edit_text(NO_SUBSCRIPTION_TEXT)
                return
                
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.edit_text("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
                
            current_time = datetime.now()
            
            if (local_sub.last_removal_reset and 
                (current_time - local_sub.last_removal_reset).days >= 30):
                local_sub.device_removal_count = 0
                local_sub.last_removal_reset = current_time
                
            if local_sub.device_removal_count >= DEVICE_REMOVAL_LIMIT:
                days_left = 30 - (current_time - local_sub.last_removal_reset).days
                await callback.message.edit_text(
                    DEVICE_REMOVAL_LIMIT_TEXT.format(days_left=days_left),
                    reply_markup=get_back_to_devices_kb(subscription_uuid)
                )
                return

            devices = await remnawave_service.get_connected_devices(subscription_uuid)
            if not devices:
                await callback.message.edit_text(
                    NO_DEVICES_TEXT,
                    reply_markup=get_back_to_manage_kb(subscription_uuid)
                )
                return
                
            if len(devices) <= 1:
                await callback.message.edit_text(
                    LAST_DEVICE_TEXT,
                    reply_markup=get_back_to_devices_kb(subscription_uuid)
                )
                return
                
            device = next((d for d in devices if d['hwid'].startswith(short_hwid)), None)
            if not device:
                await callback.message.edit_text(
                    "‚ö†Ô∏è –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
                    reply_markup=get_back_to_devices_kb(subscription_uuid)
                )
                return
                
            if not await remnawave_service.remove_device(subscription_uuid, device['hwid']):
                await callback.message.edit_text(
                    "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞",
                    reply_markup=get_back_to_devices_kb(subscription_uuid)
                )
                return
                
            local_sub.device_removal_count += 1
            if local_sub.last_removal_reset is None:
                local_sub.last_removal_reset = current_time
            await session.commit()
            
            updated_devices = await remnawave_service.get_connected_devices(subscription_uuid)
            sub_info = await remnawave_service.get_subscription_by_uuid(subscription_uuid)
            
            message_text = (
                f"‚úÖ –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ {device['hwid'][:8]} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ\n\n"
                f"üì± –û—Å—Ç–∞–ª–æ—Å—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {len(updated_devices)}"
            )
            
            await callback.message.edit_text(
                text=message_text,
                reply_markup=get_device_list_kb(
                    subscription_uuid=subscription_uuid,
                    devices=updated_devices[:DEVICES_PER_PAGE],
                    page=0,
                    total_pages=max(1, len(updated_devices) // DEVICES_PER_PAGE)
                )
            )
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: {str(e)}", exc_info=True)
        await callback.message.edit_text(
            "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞",
            reply_markup=get_back_to_manage_kb(subscription_uuid)
        )

async def initiate_transfer_subscription(callback: CallbackQuery, state: FSMContext) -> None:
    """–ù–∞—á–∞–ª–æ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏"""
    try:
        await callback.answer()
        subscription_uuid = callback.data.split(":")[1]
        
        async with async_session() as session:
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.message.answer(NO_SUBSCRIPTION_TEXT)
                return
            
            if local_sub.telegram_id != callback.from_user.id:
                await callback.message.answer("‚ö†Ô∏è –í—ã –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —ç—Ç–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")
                return
            
            if local_sub.last_transfer_time:
                days_passed = (datetime.now() - local_sub.last_transfer_time).days
                if days_passed < TRANSFER_COOLDOWN_DAYS:
                    remaining_days = TRANSFER_COOLDOWN_DAYS - days_passed
                    await callback.message.answer(
                        TRANSFER_LIMIT_WARNING.format(
                            days_passed=days_passed,
                            remaining_days=remaining_days
                        ),
                        parse_mode="HTML"
                    )
                    return
            
            await state.update_data(subscription_uuid=subscription_uuid)
            await state.set_state(TransferSubscriptionStates.waiting_for_contact)
            await callback.message.answer(
                TRANSFER_REQUEST_TEXT,
                reply_markup=get_cancel_transfer_kb(subscription_uuid)
            )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ initiate_transfer_subscription: {str(e)}", exc_info=True)
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–¥–∞—á–µ –ø–æ–¥–ø–∏—Å–∫–∏")
        await state.clear()

async def process_transfer_contact(message: Message, state: FSMContext) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–æ–≤–æ–º—É –≤–ª–∞–¥–µ–ª—å—Ü—É"""
    try:
        if not isinstance(message.contact, Contact):
            await message.answer(INVALID_CONTACT_TEXT)
            return
            
        contact_id = message.contact.user_id
        if not contact_id:
            await message.answer(INVALID_CONTACT_TEXT)
            return
            
        if contact_id == message.from_user.id:
            await message.answer(SELF_TRANSFER_TEXT)
            return
            
        data = await state.get_data()
        subscription_uuid = data.get("subscription_uuid")
        if not subscription_uuid:
            await message.answer("‚ö†Ô∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            await state.clear()
            return
            
        async with async_session() as session:
            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î
            success = await crud.update_subscription_transfer(
                session=session,
                sub_uuid=subscription_uuid,
                new_telegram_id=contact_id
            )
            
            if not success:
                await message.answer(NO_SUBSCRIPTION_TEXT)
                await state.clear()
                return
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–µ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            sub_info = await remnawave_service.get_subscription_by_uuid(subscription_uuid)
            if "error" in sub_info:
                await message.answer(f"–û—à–∏–±–∫–∞ API: {sub_info['error']}")
                await state.clear()
                return
                
            sub_name = sub_info.get('username', subscription_uuid[:8])
            
            await message.answer(
                TRANSFER_SUCCESS_TEXT.format(
                    subscription_name=sub_name,
                    contact_id=contact_id,
                    next_transfer_date=(datetime.now() + timedelta(days=TRANSFER_COOLDOWN_DAYS)).strftime('%d.%m.%Y')
                )
            )
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –Ω–æ–≤–æ–≥–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞
            await message.bot.send_message(
                contact_id,
                TRANSFER_RECIPIENT_NOTIFICATION_TEXT.format(username=sub_name),
                parse_mode="HTML"
            )
            
        await state.clear()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ process_transfer_contact: {str(e)}", exc_info=True)
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–¥–∞—á–µ –ø–æ–¥–ø–∏—Å–∫–∏")
        await state.clear()

async def cancel_transfer(callback: CallbackQuery, state: FSMContext) -> None:
    """–û—Ç–º–µ–Ω–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏"""
    try:
        await callback.answer()
        await callback.message.answer(TRANSFER_CANCELLED_TEXT)
        await state.clear()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ cancel_transfer: {str(e)}")
        await callback.message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –ø–µ—Ä–µ–¥–∞—á–∏")


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/control_subscription/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
# –¢–µ–∫—Å—Ç—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–æ–π
MANAGE_SUBSCRIPTION_TEXT = (
    "‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π <b>{username}</b>\n\n"
    "üìä –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ç—Ä–∞—Ñ–∏–∫–∞: {used_traffic:.2f} GB\n"
    "üîî –°—Ç–∞—Ç—É—Å: {status}\n"
    "üí∞ –¶–µ–Ω–∞ –ø—Ä–æ–¥–ª–µ–Ω–∏—è: {renewal_price:.2f} ‚ÇΩ\n\n"
    "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
)

NO_SUBSCRIPTION_TEXT = "‚ö†Ô∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
INSUFFICIENT_BALANCE_TEXT = "‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤. –¢—Ä–µ–±—É–µ—Ç—Å—è: {required:.2f} ‚ÇΩ, –±–∞–ª–∞–Ω—Å: {balance:.2f} ‚ÇΩ"
RENEWAL_PRICE_NOT_SET_TEXT = "‚ö†Ô∏è –¶–µ–Ω–∞ –ø—Ä–æ–¥–ª–µ–Ω–∏—è –Ω–µ —É–∫–∞–∑–∞–Ω–∞"
RENEW_SUBSCRIPTION_SUCCESS_TEXT = "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø—Ä–æ–¥–ª–µ–Ω–∞ –¥–æ {expiration}. –°–ø–∏—Å–∞–Ω–æ {amount:.2f} ‚ÇΩ"

# –¢–µ–∫—Å—Ç—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
NO_DEVICES_TEXT = "‚ö†Ô∏è –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"
DEVICES_LIST_TEXT = "üì± –ü–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ <b>{username}</b>:"
DEVICES_PAGINATION_TEXT = (
    "üì± –ü–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ <b>{username}</b>:\n\n"
    "–°—Ç—Ä–∞–Ω–∏—Ü–∞ {current_page}/{total_pages} | –í—Å–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {total_devices}"
)
DEVICE_DETAILS_TEXT = (
    "üì± –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:\n\n"
    "HWID: {hwid}\n"
    "–ò–º—è: {name}\n"
    "–û–±–Ω–æ–≤–ª–µ–Ω–æ: {updated_at}\n\n"
    "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
)
LAST_DEVICE_TEXT = "‚ö†Ô∏è –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
DEVICE_REMOVED_TEXT = "‚úÖ –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ {hwid} —É–¥–∞–ª–µ–Ω–æ"
DEVICE_REMOVAL_LIMIT_TEXT = "‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —É–¥–∞–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤ (4 –≤ –º–µ—Å—è—Ü). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ {days_left} –¥–Ω–µ–π"

# –¢–µ–∫—Å—Ç—ã –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏
TRANSFER_COOLDOWN_TEXT = "‚ö†Ô∏è –ü–æ–¥–ø–∏—Å–∫—É –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —á–µ—Ä–µ–∑ {days_left} –¥–Ω–µ–π"
TRANSFER_REQUEST_TEXT = "üì± –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–Ω—Ç–∞–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å–∫–∏:"
INVALID_CONTACT_TEXT = "‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç"
SELF_TRANSFER_TEXT = "‚ö†Ô∏è –ù–µ–ª—å–∑—è –ø–µ—Ä–µ–¥–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É —Å–∞–º–æ–º—É —Å–µ–±–µ"
TRANSFER_SUCCESS_TEXT = (
    "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ '{subscription_name}' –ø–µ—Ä–µ–¥–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID {contact_id}!\n\n"
    "–°–ª–µ–¥—É—é—â–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –≤–æ–∑–º–æ–∂–Ω–∞ –ø–æ—Å–ª–µ {next_transfer_date}"
)
TRANSFER_RECIPIENT_NOTIFICATION_TEXT = (
    "üéâ –í–∞–º –ø–µ—Ä–µ–¥–∞–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ <b>{username}</b>!\n\n"
    "–í—ã –º–æ–∂–µ—Ç–µ —É–ø—Ä–∞–≤–ª—è—Ç—å –µ–π –≤ —Ä–∞–∑–¥–µ–ª–µ '–ú–æ–∏ –ø–æ–¥–ø–∏—Å–∫–∏'.\n"
    "–ü–µ—Ä–µ–¥–∞—Ç—å —ç—Ç—É –ø–æ–¥–ø–∏—Å–∫—É –º–æ–∂–Ω–æ –±—É–¥–µ—Ç —á–µ—Ä–µ–∑ 14 –¥–Ω–µ–π."
)
TRANSFER_CANCELLED_TEXT = "‚ùå –ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞"
TRANSFER_LIMIT_WARNING = (
    "‚è≥ –≠—Ç—É –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–∏ {days_passed} –¥–Ω–µ–π –Ω–∞–∑–∞–¥.\n\n"
    "–°–æ–≥–ª–∞—Å–Ω–æ –ø—Ä–∞–≤–∏–ª–∞–º, –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –º–æ–∂–Ω–æ "
    "—Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑ –≤ 14 –¥–Ω–µ–π.\n\n"
    "–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–ø—ã—Ç–∫—É –º–æ–∂–Ω–æ –±—É–¥–µ—Ç —á–µ—Ä–µ–∑ {remaining_days} –¥–Ω–µ–π."
)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
TRANSFER_COOLDOWN_DAYS = 14  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ 14 –¥–Ω–µ–π –º–µ–∂–¥—É –ø–µ—Ä–µ–¥–∞—á–∞–º–∏
DEVICE_REMOVAL_LIMIT = 4     # –ú–∞–∫—Å–∏–º—É–º 4 —É–¥–∞–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –≤ –º–µ—Å—è—Ü
PAGINATION_PREV_BUTTON = "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"
PAGINATION_NEXT_BUTTON = "–í–ø–µ—Ä—ë–¥ ‚û°Ô∏è"
BACK_BUTTON = "üîô –ù–∞–∑–∞–¥"


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/control_subscription/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from typing import List, Dict, Optional

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –∫–Ω–æ–ø–æ–∫
BACK_BUTTON = "‚¨ÖÔ∏è –ù–∞–∑–∞–¥"
MANAGE_BUTTON = "‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ"
DEVICES_BUTTON = "üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"
RENEW_BUTTON = "üîÑ –ü—Ä–æ–¥–ª–∏—Ç—å"
TRANSFER_BUTTON = "üë§ –ü–µ—Ä–µ–¥–∞—Ç—å"
REMOVE_BUTTON = "üóë –£–¥–∞–ª–∏—Ç—å"
CANCEL_BUTTON = "‚ùå –û—Ç–º–µ–Ω–∞"
PREV_PAGE_BUTTON = "‚óÄÔ∏è"
NEXT_PAGE_BUTTON = "‚ñ∂Ô∏è"
HELP_BUTTON = "‚ùì –ü–æ–º–æ—â—å"

# –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
DEVICES_PER_PAGE = 5

def get_main_menu_kb(role: str = "USER") -> InlineKeyboardMarkup:
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é —Å —É—á–µ—Ç–æ–º —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    builder = InlineKeyboardBuilder()
    
    builder.button(text="üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="menu:profile")
    builder.button(text="üíé –ü–æ–¥–ø–∏—Å–∫–∏", callback_data="menu:subscriptions")
    
    if role in ["ADMIN", "SUPPORT"]:
        builder.button(text="üõé –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="menu:support")
    if role == "ADMIN":
        builder.button(text="üëë –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="menu:admin")
    
    builder.button(text=HELP_BUTTON, callback_data="menu:help")
    
    # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ (2 –≤ –ø–µ—Ä–≤–æ–º —Ä—è–¥—É, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ 1)
    builder.adjust(2, 1)
    return builder.as_markup()

def get_subscriptions_list_kb(subscriptions: List[Dict]) -> InlineKeyboardMarkup:
    """–°–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    builder = InlineKeyboardBuilder()
    
    for sub in subscriptions:
        builder.button(
            text=sub['username'],
            callback_data=f"subscription_detail:{sub['uuid']}"
        )
    
    builder.button(text="üõí –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="buy_subscription")
    builder.button(text=BACK_BUTTON, callback_data="menu:main")
    
    builder.adjust(1, 2)
    return builder.as_markup()

def get_subscription_detail_kb(subscription_uuid: str, subscription_url: str) -> InlineKeyboardMarkup:
    """–î–µ—Ç–∞–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∏"""
    builder = InlineKeyboardBuilder()
    
    builder.button(text="üîó –°—Å—ã–ª–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è", url=subscription_url)
    builder.button(text=MANAGE_BUTTON, callback_data=f"manage_subscription:{subscription_uuid}")
    builder.button(text=BACK_BUTTON, callback_data="menu:subscriptions")
    
    builder.adjust(1, 1, 1)
    return builder.as_markup()

def get_manage_subscription_kb(subscription_uuid: str) -> InlineKeyboardMarkup:
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–æ–π"""
    builder = InlineKeyboardBuilder()
    
    builder.button(text=RENEW_BUTTON, callback_data=f"renew_subscription:{subscription_uuid}")
    builder.button(text=DEVICES_BUTTON, callback_data=f"view_devices:{subscription_uuid}:0")
    builder.button(text=TRANSFER_BUTTON, callback_data=f"transfer_subscription:{subscription_uuid}")
    builder.button(text=BACK_BUTTON, callback_data=f"subscription_detail:{subscription_uuid}")
    
    builder.adjust(1, 2, 1)
    return builder.as_markup()

def get_device_list_kb(
    subscription_uuid: str,
    devices: List[Dict],
    page: int,
    total_pages: int
) -> InlineKeyboardMarkup:
    """–°–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π"""
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
    for device in devices:
        device_name = f"{device['platform']} {device['device_model']}".strip() or device['hwid'][:8]
        builder.button(
            text=device_name,
            callback_data=f"device_details:{subscription_uuid}:{device['hwid'][:8]}"
        )
    
    # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
    pagination_row = []
    if page > 0:
        pagination_row.append(
            InlineKeyboardButton(
                text=PREV_PAGE_BUTTON,
                callback_data=f"view_devices:{subscription_uuid}:{page-1}"
            )
        )
    if page < total_pages - 1:
        pagination_row.append(
            InlineKeyboardButton(
                text=NEXT_PAGE_BUTTON,
                callback_data=f"view_devices:{subscription_uuid}:{page+1}"
            )
        )
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è
    builder.row(*pagination_row)
    builder.button(text=BACK_BUTTON, callback_data=f"manage_subscription:{subscription_uuid}")
    
    builder.adjust(1, *[1]*len(devices), len(pagination_row), 1)
    return builder.as_markup()

def get_device_details_kb(subscription_uuid: str, hwid: str) -> InlineKeyboardMarkup:
    """–î–µ—Ç–∞–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
    builder = InlineKeyboardBuilder()
    
    builder.button(
        text=REMOVE_BUTTON,
        callback_data=f"remove_device:{subscription_uuid}:{hwid[:8]}"
    )
    builder.button(
        text=BACK_BUTTON,
        callback_data=f"view_devices:{subscription_uuid}:0"
    )
    
    builder.adjust(1, 1)
    return builder.as_markup()

def get_cancel_transfer_kb(subscription_uuid: str) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –æ—Ç–º–µ–Ω—ã –ø–µ—Ä–µ–¥–∞—á–∏"""
    builder = InlineKeyboardBuilder()
    builder.button(
        text=CANCEL_BUTTON,
        callback_data=f"cancel_transfer:{subscription_uuid}"
    )
    return builder.as_markup()

def get_back_to_devices_kb(subscription_uuid: str) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —Å–ø–∏—Å–∫—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤"""
    builder = InlineKeyboardBuilder()
    builder.button(
        text="‚¨ÖÔ∏è –ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º",
        callback_data=f"view_devices:{subscription_uuid}:0"
    )
    return builder.as_markup()

def get_back_to_manage_kb(subscription_uuid: str) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–æ–¥–ø–∏—Å–∫–æ–π"""
    builder = InlineKeyboardBuilder()
    builder.button(
        text="‚¨ÖÔ∏è –ö —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é",
        callback_data=f"manage_subscription:{subscription_uuid}"
    )
    return builder.as_markup()

def get_no_subscriptions_kb() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –ø–æ–¥–ø–∏—Å–æ–∫"""
    builder = InlineKeyboardBuilder()
    builder.button(text="üõí –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="buy_subscription")
    builder.button(text=BACK_BUTTON, callback_data="menu:main")
    builder.adjust(1, 1)
    return builder.as_markup()

--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/user/subscription ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/subscription/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram import Router, F
from .handlers import show_subscriptions, show_subscription_detail
from .texts import SUBSCRIPTIONS_CALLBACK, SUBSCRIPTION_DETAIL_CALLBACK

# –°–æ–∑–¥–∞–µ–º —Ä–æ—É—Ç–µ—Ä –º–æ–¥—É–ª—è –ø–æ–¥–ø–∏—Å–æ–∫
subscriptions_router = Router()

# –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
subscriptions_router.callback_query.register(
    show_subscriptions,
    F.data == SUBSCRIPTIONS_CALLBACK
)

subscriptions_router.callback_query.register(
    show_subscription_detail,
    F.data.startswith(SUBSCRIPTION_DETAIL_CALLBACK)
)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/subscription/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.types import CallbackQuery
from core.database.crud import get_purchased_subscriptions
from core.api.remnawave_client import remnawave_service
from . import texts, keyboards
from core.database.database import async_session
import logging
from core.database import crud

logger = logging.getLogger(__name__)

async def show_subscriptions(callback: CallbackQuery) -> None:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ä–∞–∑–¥–µ–ª–∞ '–ú–æ–∏ –ø–æ–¥–ø–∏—Å–∫–∏' (—Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)"""
    try:
        await callback.answer()
        user_id = callback.from_user.id
        
        async with async_session() as session:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–ø–∏—Å–∫–∏ —Ç–æ–ª—å–∫–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î
            local_subscriptions = await get_purchased_subscriptions(session, user_id)
            
            if not local_subscriptions:
                await callback.message.edit_text(
                    texts.NO_SUBSCRIPTIONS_TEXT,
                    reply_markup=keyboards.get_no_subscriptions_kb()
                )
                return
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å–æ–∫ –¥–ª—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            subscriptions_info = []
            for sub in local_subscriptions:
                subscriptions_info.append({
                    "uuid": sub.sub_uuid,
                    "username": sub.username
                })
            
            await callback.message.edit_text(
                texts.SUBSCRIPTIONS_LIST_TEXT,
                reply_markup=keyboards.get_subscriptions_list_kb(subscriptions_info)
            )
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ show_subscriptions: {str(e)}", exc_info=True)
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–æ–¥–ø–∏—Å–æ–∫", show_alert=True)

async def show_subscription_detail(callback: CallbackQuery) -> None:
    """–î–µ—Ç–∞–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∏ —Å –∑–∞–ø—Ä–æ—Å–æ–º –≤ API –ø–æ UUID"""
    try:
        await callback.answer()
        subscription_uuid = callback.data.split(":")[1]
        
        async with async_session() as session:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î
            local_sub = await crud.get_purchased_subscription_by_uuid(session, subscription_uuid)
            if not local_sub:
                await callback.answer("‚ö†Ô∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return
            
            # –ó–∞–ø—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–∫–∏ –≤ API
            sub_info = await remnawave_service.get_subscription_by_uuid(subscription_uuid)
            
            if "error" in sub_info:
                await callback.message.answer(
                    texts.SUBSCRIPTION_ERROR_TEXT.format(error=sub_info['error'])
                )
                return
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            status_emoji = {
                "active": "üü¢",
                "disabled": "üî¥",
                "expired": "üü†",
                "limited": "üü°"
            }.get(sub_info["status"].lower(), "‚ö™Ô∏è")
            
            message_text = texts.SUBSCRIPTION_DETAIL_TEMPLATE.format(
                status_emoji=status_emoji,
                username=local_sub.username,
                status=sub_info['status'].capitalize(),
                used_traffic=sub_info['used_traffic_bytes'] / (1024 ** 3),
                data_limit=sub_info['data_limit'],
                expire=sub_info['expire'],
                last_connected=sub_info['last_connected_node'],
                purchase_price=float(local_sub.purchase_price) if local_sub.purchase_price else 0.0,
                renewal_price=float(local_sub.renewal_price) if local_sub.renewal_price else 0.0
            )
            
            await callback.message.edit_text(
                text=message_text,
                reply_markup=keyboards.get_subscription_detail_kb(
                    subscription_uuid=subscription_uuid,
                    subscription_url=sub_info['subscription_url']
                ),
                parse_mode="HTML"
            )
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ show_subscription_detail: {str(e)}", exc_info=True)
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–æ–¥–ø–∏—Å–∫–∏", show_alert=True)


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/subscription/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
# –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã
NO_SUBSCRIPTIONS_TEXT = (
    "üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫.\n\n"
    "–ü—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –Ω–∞—à–∏–º —É—Å–ª—É–≥–∞–º! üõí"
)

SUBSCRIPTIONS_LIST_TEXT = "üìã –í–∞—à–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏:"

SUBSCRIPTION_DETAIL_TEMPLATE = (
    "{status_emoji} <b>{username}</b> ‚ú®\n"
    "üìà –°—Ç–∞—Ç—É—Å: {status}\n"
    "üåê –¢—Ä–∞—Ñ–∏–∫: {used_traffic:.2f} GB / {data_limit:.2f} GB\n"
    "‚è≥ –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: {expire}\n"
    "üìç –ü–æ—Å–ª–µ–¥–Ω–µ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: {last_connected}\n"
    "üí∞ –¶–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏: {purchase_price:.2f} ‚ÇΩ\n"
    "üîÑ –¶–µ–Ω–∞ –ø—Ä–æ–¥–ª–µ–Ω–∏—è: {renewal_price:.2f} ‚ÇΩ\n"
)

SUBSCRIPTION_ERROR_TEXT = "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–∫–∏:\n{error}"

# –¢–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫
BUY_SUBSCRIPTION_TEXT = "üõí –ö—É–ø–∏—Ç—å"
BUY_ANOTHER_TEXT = "üõí –ö—É–ø–∏—Ç—å"
BACK_TO_LIST_TEXT = "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É"
REFRESH_TEXT = "üîÑ –û–±–Ω–æ–≤–∏—Ç—å"
MANAGE_SUBSCRIPTION_TEXT = "‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π"
SUBSCRIPTION_LINK_TEXT = "üîó –°—Å—ã–ª–∫–∞ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è"
MAIN_MENU_TEXT = "üè† –ú–µ–Ω—é"

# Callback data
SUBSCRIPTIONS_CALLBACK = "subscriptions"
SUBSCRIPTION_DETAIL_CALLBACK = "subscription_detail:"
BUY_SUBSCRIPTION_CALLBACK = "buy_subscription"
MANAGE_SUBSCRIPTION_CALLBACK = "manage_subscription:"
MAIN_MENU_CALLBACK = "menu:main"

--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/subscription/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton
from .texts import (
    BUY_SUBSCRIPTION_TEXT, BUY_ANOTHER_TEXT, 
    BACK_TO_LIST_TEXT, REFRESH_TEXT,
    SUBSCRIPTION_DETAIL_CALLBACK, BUY_SUBSCRIPTION_CALLBACK,
    SUBSCRIPTIONS_CALLBACK, SUBSCRIPTION_LINK_TEXT,
    MANAGE_SUBSCRIPTION_TEXT, MANAGE_SUBSCRIPTION_CALLBACK,
    MAIN_MENU_TEXT, MAIN_MENU_CALLBACK
)

def get_subscriptions_list_kb(subscriptions: list) -> InlineKeyboardBuilder:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å–ø–∏—Å–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫ (—Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)"""
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–¥–ø–∏—Å–∫–∏
    for sub in subscriptions:
        builder.button(
            text=sub["username"],
            callback_data=f"{SUBSCRIPTION_DETAIL_CALLBACK}{sub['uuid']}"
        )
    
    builder.adjust(1)
    builder.row(
        InlineKeyboardButton(
            text=BUY_ANOTHER_TEXT,
            callback_data=BUY_SUBSCRIPTION_CALLBACK
        ),
        InlineKeyboardButton(
            text=MAIN_MENU_TEXT,
            callback_data=MAIN_MENU_CALLBACK
        )
    )
    
    return builder.as_markup()

# –û—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
def get_no_subscriptions_kb() -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text=BUY_SUBSCRIPTION_TEXT,
            callback_data=BUY_SUBSCRIPTION_CALLBACK
        ),
        InlineKeyboardButton(
            text=MAIN_MENU_TEXT,
            callback_data=MAIN_MENU_CALLBACK
        )
    )
    return builder.as_markup()

def get_subscription_detail_kb(subscription_uuid: str, subscription_url: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text=SUBSCRIPTION_LINK_TEXT,
            url=subscription_url
        )
    )
    builder.row(
        InlineKeyboardButton(
            text=MANAGE_SUBSCRIPTION_TEXT,
            callback_data=f"{MANAGE_SUBSCRIPTION_CALLBACK}{subscription_uuid}"
        )
    )
    builder.row(
        InlineKeyboardButton(
            text=BACK_TO_LIST_TEXT,
            callback_data=SUBSCRIPTIONS_CALLBACK
        )
    )
    return builder.as_markup()


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/user/subscription/__init__.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from .router import subscriptions_router


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/support ===

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/support/tickets ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/tickets/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/tickets/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/tickets/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/tickets/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/modules/support/main_menu ===

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/main_menu/router.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/main_menu/handlers.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/main_menu/texts.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/modules/support/main_menu/keyboards.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/core ===

üìÑ –§–ê–ô–õ: /home/REMBOT/core/auth.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from sqlalchemy.ext.asyncio import AsyncSession
from core.database.crud import get_user_by_telegram_id, update_user
from core.marzban_api.api import MarzbanAPI
import logging
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

class AuthService:
    def __init__(self, marzban_api: MarzbanAPI):
        self.marzban_api = marzban_api

    async def sync_with_marzban(
        self, 
        session: AsyncSession, 
        telegram_id: int
    ) -> Dict[str, Any]:
        result = {
            "marzban_user_exists": False,
            "error": None
        }

        try:
            user = await get_user_by_telegram_id(session, telegram_id)
            if not user:
                result["error"] = "User not found in DB"
                return result

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º telegram_id –µ—Å–ª–∏ username –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
            marzban_username = user.username or str(telegram_id)
            marzban_user = await self.marzban_api.get_user(marzban_username)
            
            result["marzban_user_exists"] = marzban_user is not None

        except Exception as e:
            result["error"] = str(e)
            logger.error(f"Sync error: {str(e)}", exc_info=True)
            
        return result


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/core/filters.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from typing import Union, Optional

class RoleFilter(BaseFilter):
    def __init__(self, required_role: str):
        self.required_role = required_role.upper()

    async def __call__(
        self, 
        event: Union[Message, CallbackQuery], 
        role: Optional[str] = None, 
        **kwargs
    ) -> bool:
        return role and role.upper() == self.required_role

class HasAnyRole(BaseFilter):
    def __init__(self, roles: list | tuple | set):
        self.allowed_roles = {r.upper() for r in roles}

    async def __call__(
        self, 
        event: Union[Message, CallbackQuery], 
        role: Optional[str] = None, 
        **kwargs
    ) -> bool:
        return role and role.upper() in self.allowed_roles

# –ì–æ—Ç–æ–≤—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã —Ñ–∏–ª—å—Ç—Ä–æ–≤
IsAdmin = RoleFilter("ADMIN")
IsSupport = RoleFilter("SUPPORT")
IsUser = RoleFilter("USER")
IsBanned = RoleFilter("BANNED")
IsStaff = HasAnyRole({"ADMIN", "SUPPORT"})
IsNotBanned = HasAnyRole({"USER", "ADMIN", "SUPPORT"})


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/core/__init__.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/core/middleware.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from typing import Callable, Dict, Awaitable, Any, Union
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message, CallbackQuery, Update
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
from core.database.crud import get_user_by_telegram_id, create_user
from core.database.model import User
import logging

logger = logging.getLogger(__name__)

class RoleMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker[AsyncSession]):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        logger.debug(f"RoleMiddleware processing event: {type(event)}")
        data.update({"user": None, "role": "USER"})

        # Extract actual event from Update if needed
        actual_event = event
        if isinstance(event, Update):
            actual_event = event.message or event.callback_query
            if not actual_event:
                logger.debug("Unsupported Update event type")
                return await handler(event, data)

        # Check if we have a supported event with from_user
        if not isinstance(actual_event, (Message, CallbackQuery)) or not actual_event.from_user:
            logger.debug("Event doesn't have from_user, skipping user processing")
            return await handler(event, data)

        user = actual_event.from_user
        telegram_id = user.id
        logger.debug(f"Processing user with telegram_id: {telegram_id}")

        try:
            async with self.session_pool() as session:
                async with session.begin():
                    # Try to get existing user
                    db_user = await get_user_by_telegram_id(session, telegram_id)
                    
                    # Create new user if doesn't exist
                    if not db_user:
                        logger.debug(f"Creating new user for telegram_id: {telegram_id}")
                        db_user = await create_user(
                            session=session,
                            telegram_id=telegram_id,
                            username=user.username
                        )
                        
                        if not db_user:
                            logger.error(f"Failed to create user for telegram_id: {telegram_id}")
                            return await handler(event, data)

                    # Update data for handler
                    data.update({
                        "user": db_user,
                        "role": db_user.role.upper() if db_user else "USER"
                    })
                    logger.debug(f"User data updated: {data['role']}")

        except Exception as e:
            logger.error(f"Error processing user {telegram_id}: {str(e)}", exc_info=True)
            # Continue with default data (user=None, role=USER)
        
        return await handler(event, data)

--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/core/database ===

üìÑ –§–ê–ô–õ: /home/REMBOT/core/database/model.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from datetime import datetime
from sqlalchemy import (
    Column, Integer, BigInteger, String, DateTime, 
    Text, Index, func, ForeignKey, CheckConstraint,
    UniqueConstraint, Boolean, Numeric
)
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase, relationship

class Base(AsyncAttrs, DeclarativeBase):
    pass

class User(Base):
    __tablename__ = "users"
    __table_args__ = (
        Index('idx_user_telegram_id', 'telegram_id'),
        Index('idx_user_username', 'username'),
        CheckConstraint(
            "role IN ('ADMIN', 'SUPPORT', 'USER', 'BANNED')", 
            name="check_user_role"
        ),
    )

    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    username = Column(String(255), nullable=True, index=True)
    role = Column(String(20), nullable=False, server_default="USER")
    balance = Column(Numeric(10, 2), default=0, nullable=False)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    last_sync_time = Column(DateTime, nullable=True)

    # Relationships
    purchased_subscriptions = relationship("PurchasedSubscription", back_populates="user")
    used_promocodes = relationship("UsedPromocode", back_populates="user")

class PurchasedSubscription(Base):
    __tablename__ = "purchased_subscriptions"
    __table_args__ = (
        Index('idx_purchased_sub_telegram_id', 'telegram_id'),
        Index('idx_purchased_sub_uuid', 'sub_uuid'),
    )

    id = Column(Integer, primary_key=True)
    telegram_id = Column(
        BigInteger, 
        ForeignKey("users.telegram_id", ondelete="CASCADE"), 
        nullable=False, 
        index=True
    )
    sub_uuid = Column(String(255), nullable=False)
    username = Column(String(255), nullable=False)  # –ù–æ–≤–æ–µ –ø–æ–ª–µ
    purchase_price = Column(Numeric(10, 2), nullable=True)
    renewal_price = Column(Numeric(10, 2), nullable=True)
    expired_at = Column(DateTime, nullable=False)
    last_transfer_time = Column(DateTime, nullable=True)
    device_removal_count = Column(Integer, default=0, nullable=False)
    last_removal_reset = Column(DateTime, nullable=True)
    
    # Relationship
    user = relationship("User", back_populates="purchased_subscriptions")

class SubscriptionPlan(Base):
    __tablename__ = "subscriptions_plan"
    __table_args__ = (
        UniqueConstraint('name', name='uq_subscription_plan_name'),
    )

    id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False, unique=True)
    price = Column(Numeric(10, 2), nullable=False)
    end_date = Column(DateTime, nullable=False)

class Promocode(Base):
    __tablename__ = "promocodes"
    __table_args__ = (
        UniqueConstraint('code', name='uq_promocode_code'),
        Index('idx_promocode_is_active', 'is_active'),
    )

    id = Column(Integer, primary_key=True)
    code = Column(String(50), nullable=False, unique=True)
    total_uses = Column(Integer, nullable=False)
    remaining_uses = Column(Integer, nullable=False)
    uses_per_user = Column(Integer, nullable=False)
    discount_value = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    valid_until = Column(DateTime, nullable=False)

class UsedPromocode(Base):
    __tablename__ = "used_promocodes"
    __table_args__ = (
        Index('idx_used_promo_telegram_id', 'telegram_id'),
        Index('idx_used_promo_promo_id', 'promo_id'),
    )

    id = Column(Integer, primary_key=True)
    telegram_id = Column(
        BigInteger, 
        ForeignKey("users.telegram_id", ondelete="CASCADE"), 
        nullable=False, 
        index=True
    )
    promo_id = Column(
        Integer, 
        ForeignKey("promocodes.id", ondelete="CASCADE"), 
        nullable=False, 
        index=True
    )
    valid_until = Column(DateTime)
    use_status = Column(Boolean, default=True, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="used_promocodes")
    promocode = relationship("Promocode")


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/core/database/crud.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import selectinload
from core.database.model import User, PurchasedSubscription, SubscriptionPlan, Promocode, UsedPromocode
from typing import Optional, List, Union, Dict, Any
from datetime import datetime, timedelta
from decimal import Decimal
import logging

logger = logging.getLogger(__name__)

# ==================== USER OPERATIONS ====================

async def create_user(
    session: AsyncSession,
    telegram_id: int,
    username: Optional[str] = None,
    balance: Decimal = Decimal('0'),
    role: str = "USER"
) -> Optional[User]:
    """Create new user in database"""
    try:
        user = User(
            telegram_id=telegram_id,
            username=username,
            balance=balance,
            role=role
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        logger.debug(f"Created user: {user.telegram_id}")
        return user
    except Exception as e:
        logger.error(f"Error creating user {telegram_id}: {str(e)}", exc_info=True)
        await session.rollback()
        return None

async def get_user_by_telegram_id(
    session: AsyncSession,
    telegram_id: int
) -> Optional[User]:
    """Get user by Telegram ID"""
    try:
        result = await session.execute(
            select(User)
            .where(User.telegram_id == telegram_id)
        )
        return result.scalars().first()
    except Exception as e:
        logger.error(f"Error getting user {telegram_id}: {str(e)}", exc_info=True)
        return None

async def update_user_balance(
    session: AsyncSession,
    telegram_id: int,
    amount: Decimal
) -> bool:
    """Update user balance"""
    try:
        user = await get_user_by_telegram_id(session, telegram_id)
        if not user:
            return False
            
        user.balance += amount
        await session.flush()
        return True
    except Exception as e:
        logger.error(f"Error updating balance for {telegram_id}: {str(e)}", exc_info=True)
        await session.rollback()
        return False

# ==================== SUBSCRIPTION OPERATIONS ====================

async def update_subscription_transfer(
    session: AsyncSession,
    sub_uuid: str,
    new_telegram_id: int
) -> bool:
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–ª–∞–¥–µ–ª—å—Ü–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –ø—Ä–∏ –ø–µ—Ä–µ–¥–∞—á–µ"""
    try:
        result = await session.execute(
            update(PurchasedSubscription)
            .where(PurchasedSubscription.sub_uuid == sub_uuid)
            .values(
                telegram_id=new_telegram_id,
                last_transfer_time=datetime.now()
            )
        )
        await session.commit()
        return result.rowcount > 0
    except Exception as e:
        logger.error(f"Error transferring subscription {sub_uuid}: {str(e)}", exc_info=True)
        await session.rollback()
        return False

async def create_or_update_subscription(
    session: AsyncSession,
    telegram_id: int,
    sub_uuid: str,
    username: str,
    expired_at: datetime,
    purchase_price: Optional[Decimal] = None,
    renewal_price: Optional[Decimal] = None
) -> Optional[PurchasedSubscription]:
    """Create or update subscription"""
    try:
        subscription = await get_purchased_subscription_by_uuid(session, sub_uuid)
        
        if subscription:
            # Update existing subscription
            subscription.telegram_id = telegram_id
            subscription.username = username
            subscription.expired_at = expired_at
            if purchase_price is not None:
                subscription.purchase_price = purchase_price
            if renewal_price is not None:
                subscription.renewal_price = renewal_price
        else:
            # Create new subscription
            subscription = PurchasedSubscription(
                telegram_id=telegram_id,
                sub_uuid=sub_uuid,
                username=username,
                purchase_price=purchase_price,
                renewal_price=renewal_price,
                expired_at=expired_at
            )
            session.add(subscription)
        
        await session.flush()
        await session.refresh(subscription)
        return subscription
    except Exception as e:
        logger.error(f"Error with subscription {sub_uuid}: {str(e)}", exc_info=True)
        await session.rollback()
        return None

async def get_purchased_subscription_by_uuid(
    session: AsyncSession, 
    sub_uuid: str
) -> Optional[PurchasedSubscription]:
    """Get subscription by UUID"""
    try:
        result = await session.execute(
            select(PurchasedSubscription)
            .where(PurchasedSubscription.sub_uuid == sub_uuid)
        )
        return result.scalars().first()
    except Exception as e:
        logger.error(f"Error getting subscription {sub_uuid}: {str(e)}", exc_info=True)
        return None

async def get_purchased_subscriptions(
    session: AsyncSession, 
    telegram_id: int
) -> List[PurchasedSubscription]:
    """Get all user subscriptions"""
    try:
        result = await session.execute(
            select(PurchasedSubscription)
            .where(PurchasedSubscription.telegram_id == telegram_id)
            .order_by(PurchasedSubscription.expired_at.desc())
        )
        return list(result.scalars().all())
    except Exception as e:
        logger.error(f"Error getting subscriptions for {telegram_id}: {str(e)}", exc_info=True)
        return []

async def transfer_subscription_ownership(
    session: AsyncSession,
    sub_uuid: str,
    new_telegram_id: int
) -> bool:
    """Transfer subscription to new owner"""
    try:
        result = await session.execute(
            update(PurchasedSubscription)
            .where(PurchasedSubscription.sub_uuid == sub_uuid)
            .values(
                telegram_id=new_telegram_id,
                last_transfer_time=datetime.now()
            )
        )
        await session.flush()
        return result.rowcount > 0
    except Exception as e:
        logger.error(f"Error transferring subscription {sub_uuid}: {str(e)}", exc_info=True)
        await session.rollback()
        return False

async def update_subscription_expiration(
    session: AsyncSession,
    sub_uuid: str,
    new_expiration: datetime
) -> bool:
    """Update subscription expiration date"""
    try:
        result = await session.execute(
            update(PurchasedSubscription)
            .where(PurchasedSubscription.sub_uuid == sub_uuid)
            .values(expired_at=new_expiration)
        )
        await session.flush()
        return result.rowcount > 0
    except Exception as e:
        logger.error(f"Error updating expiration for {sub_uuid}: {str(e)}", exc_info=True)
        await session.rollback()
        return False

async def update_device_removal_count(
    session: AsyncSession,
    sub_uuid: str,
    increment: bool = True
) -> bool:
    """Update device removal counter"""
    try:
        subscription = await get_purchased_subscription_by_uuid(session, sub_uuid)
        if not subscription:
            return False
            
        if increment:
            subscription.device_removal_count += 1
        else:
            subscription.device_removal_count = 0
            subscription.last_removal_reset = datetime.now()
            
        await session.flush()
        return True
    except Exception as e:
        logger.error(f"Error updating device removal for {sub_uuid}: {str(e)}", exc_info=True)
        await session.rollback()
        return False

# ==================== PROMOCODE OPERATIONS ====================

async def get_active_promocode(
    session: AsyncSession,
    code: str
) -> Optional[Promocode]:
    """Get active promocode"""
    try:
        result = await session.execute(
            select(Promocode)
            .where(Promocode.code == code)
            .where(Promocode.is_active == True)
            .where(Promocode.valid_until >= datetime.now())
        )
        return result.scalars().first()
    except Exception as e:
        logger.error(f"Error getting promocode {code}: {str(e)}", exc_info=True)
        return None

async def create_used_promocode(
    session: AsyncSession,
    telegram_id: int,
    promo_id: int,
    valid_until: Optional[datetime] = None
) -> Optional[UsedPromocode]:
    """Create used promocode record"""
    try:
        used_promo = UsedPromocode(
            telegram_id=telegram_id,
            promo_id=promo_id,
            valid_until=valid_until
        )
        session.add(used_promo)
        await session.flush()
        await session.refresh(used_promo)
        return used_promo
    except Exception as e:
        logger.error(f"Error creating used promocode: {str(e)}", exc_info=True)
        await session.rollback()
        return None

# ==================== UTILITY FUNCTIONS ====================

async def get_user_full_data(
    session: AsyncSession,
    telegram_id: int
) -> Optional[Dict[str, Any]]:
    """Get complete user data"""
    try:
        user = await get_user_by_telegram_id(session, telegram_id)
        if not user:
            return None
            
        subscriptions = await get_purchased_subscriptions(session, telegram_id)
        active_subscriptions = [s for s in subscriptions if s.expired_at > datetime.now()]
        
        return {
            "user": user,
            "subscriptions": active_subscriptions,
            "subscriptions_count": len(active_subscriptions)
        }
    except Exception as e:
        logger.error(f"Error getting full data for {telegram_id}: {str(e)}", exc_info=True)
        return None


--------------------------------------------------

üìÑ –§–ê–ô–õ: /home/REMBOT/core/database/database.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from dotenv import load_dotenv
import os  

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ü–æ–ª—É—á–∞–µ–º URL –ë–î –∏–∑ .env
DATABASE_URL = os.getenv("DATABASE_URL")  # –î–æ–±–∞–≤–ª—è–µ–º —ç—Ç—É —Å—Ç—Ä–æ–∫—É

#–°–æ–∑–¥–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫
engine = create_async_engine(DATABASE_URL)

Base = declarative_base()

async_session = async_sessionmaker(
    bind=engine,
    expire_on_commit=False,
    class_=AsyncSession
)


--------------------------------------------------

=== –î–ò–†–ï–ö–¢–û–†–ò–Ø: /home/REMBOT/core/api ===

üìÑ –§–ê–ô–õ: /home/REMBOT/core/api/remnawave_client.py
üîπ –°–û–î–ï–†–ñ–ò–ú–û–ï:
import os
import logging
from typing import Dict, Any, List, Optional
from uuid import UUID
from remnawave_api import RemnawaveSDK
from remnawave_api.models import (
    TelegramUserResponseDto,
    UpdateUserRequestDto,
    UserResponseDto,
    UserActiveInboundsDto,
    UserLastConnectedNodeDto,
    HWIDUserResponseDtoList,
    HWIDDeleteRequest,
    HWIDUserResponseDto
)
from remnawave_api.exceptions import (
    ApiError,
    NotFoundError,
    BadRequestError,
    ForbiddenError,
    UnauthorizedError,
    ConflictError,
    ServerError
)
from pydantic import ValidationError

logger = logging.getLogger(__name__)

class RemnawaveService:
    def __init__(self, base_url: str, token: str):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Remnawave API
        :param base_url: –ë–∞–∑–æ–≤—ã–π URL API
        :param token: –¢–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        """
        self.client = RemnawaveSDK(base_url=base_url, token=token)
    
    async def _transform_user_response(self, user: UserResponseDto) -> Dict[str, Any]:
        """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ UserResponseDto –≤ —Å–ª–æ–≤–∞—Ä—å"""
        # –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞—Ç—ã
        def format_date(date_field):
            if date_field:
                try:
                    return date_field.strftime("%Y-%m-%d %H:%M:%S")
                except AttributeError:
                    return str(date_field)
            return "N/A"
        
        # –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π
        def get_value(field):
            if field is None:
                return None
            try:
                return field.value
            except AttributeError:
                return field
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å
        status = get_value(user.status) if user.status else "unknown"
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º last_connected_node
        last_connected_node = "N/A"
        if user.last_connected_node:
            try:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–º–µ–Ω –∞—Ç—Ä–∏–±—É—Ç–æ–≤
                if hasattr(user.last_connected_node, 'node_name'):
                    last_connected_node = user.last_connected_node.node_name
                elif hasattr(user.last_connected_node, 'nodeName'):
                    last_connected_node = user.last_connected_node.nodeName
                else:
                    last_connected_node = str(user.last_connected_node)
            except Exception:
                last_connected_node = str(user.last_connected_node)
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∏–Ω–±–∞—É–Ω–¥—ã
        inbounds = ["N/A"]
        if user.active_user_inbounds:
            try:
                inbounds = []
                for inbound in user.active_user_inbounds:
                    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–º–µ–Ω –∞—Ç—Ä–∏–±—É—Ç–æ–≤
                    tag = inbound.tag if hasattr(inbound, 'tag') else (
                        inbound.nodeName if hasattr(inbound, 'nodeName') else "Unknown"
                    )
                    type_ = inbound.type if hasattr(inbound, 'type') else (
                        inbound.nodeType if hasattr(inbound, 'nodeType') else "Unknown"
                    )
                    inbounds.append(f"{tag} ({type_})")
            except Exception:
                inbounds = [str(inbound) for inbound in user.active_user_inbounds]
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º happ.crypto_link
        happ_crypto_link = "N/A"
        if user.happ:
            try:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–º–µ–Ω –∞—Ç—Ä–∏–±—É—Ç–æ–≤
                if hasattr(user.happ, 'crypto_link'):
                    happ_crypto_link = user.happ.crypto_link
                elif hasattr(user.happ, 'cryptoLink'):
                    happ_crypto_link = user.happ.cryptoLink
                else:
                    happ_crypto_link = str(user.happ)
            except Exception:
                pass
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        logger.debug(f"–ê—Ç—Ä–∏–±—É—Ç—ã –æ–±—ä–µ–∫—Ç–∞ UserResponseDto: {vars(user)}")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç—Ä–æ–≥–æ –ø–æ –º–æ–¥–µ–ª–∏ —Å —É—á–µ—Ç–æ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–ª–µ–π
        return {
            # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (–±–µ–∑ Optional)
            "uuid": str(user.uuid),
            "subscription_uuid": str(user.subscription_uuid),
            "short_uuid": user.short_uuid,
            "username": user.username,
            "used_traffic_bytes": user.used_traffic_bytes,
            "lifetime_used_traffic_bytes": user.lifetime_used_traffic_bytes,
            "trojan_password": user.trojan_password,
            "vless_uuid": str(user.vless_uuid),
            "ss_password": user.ss_password,
            "subscription_url": user.subscription_url,
            "created_at": format_date(user.created_at),
            "updated_at": format_date(user.updated_at),
            
            # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–æ–ª—è (—Å Optional –≤ –º–æ–¥–µ–ª–∏)
            "status": status,
            "data_limit": user.traffic_limit_bytes / (1024 ** 3) if user.traffic_limit_bytes else 0,
            "traffic_limit_strategy": get_value(user.traffic_limit_strategy) if user.traffic_limit_strategy else "N/A",
            "expire": format_date(user.expire_at) if user.expire_at else "N/A",
            "last_connected_node": last_connected_node,
            "sub_last_opened_at": format_date(user.sub_last_opened_at) if user.sub_last_opened_at else "N/A",
            "inbounds": inbounds,
            "sub_last_user_agent": user.sub_last_user_agent or "N/A",
            "online_at": format_date(user.online_at) if user.online_at else "N/A",
            "sub_revoked_at": format_date(user.sub_revoked_at) if user.sub_revoked_at else "N/A",
            "last_traffic_reset_at": format_date(user.last_traffic_reset_at) if user.last_traffic_reset_at else "N/A",
            "description": user.description or "N/A",
            "telegram_id": user.telegram_id or "N/A",
            "email": user.email or "N/A",
            "hwid_device_limit": user.hwidDeviceLimit or "N/A",
            "last_triggered_threshold": getattr(user, 'last_triggered_threshold', 0),
            "happ_crypto_link": happ_crypto_link,
            "first_connected_at": format_date(getattr(user, 'first_connected', None)) if getattr(user, 'first_connected', None) else "N/A"
        }
    
    async def get_user_by_telegram_id(self, telegram_id: int) -> List[Dict[str, Any]]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–¥–ø–∏—Å–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID
        :param telegram_id: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram
        :return: –°–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å–æ–∫ –∏–ª–∏ —Å–ø–∏—Å–æ–∫ —Å –æ—à–∏–±–∫–æ–π
        """
        try:
            if not telegram_id:
                logger.error("–ü—É—Å—Ç–æ–π Telegram ID")
                return [{"error": "–ù–µ —É–∫–∞–∑–∞–Ω Telegram ID"}]

            logger.debug(f"–ó–∞–ø—Ä–æ—Å –ø–æ–¥–ø–∏—Å–æ–∫ –¥–ª—è Telegram ID {telegram_id}")
            
            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ API
            response: TelegramUserResponseDto = await self.client.users.get_users_by_telegram_id(str(telegram_id))
            
            if not response.response:
                logger.info(f"–ü–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è Telegram ID {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                return []

            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–≤–µ—Ç API
            subscriptions = [await self._transform_user_response(user) for user in response.response]
            
            logger.info(f"–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ {len(subscriptions)} –ø–æ–¥–ø–∏—Å–æ–∫ –¥–ª—è {telegram_id}")
            return subscriptions

        except NotFoundError:
            logger.warning(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return [{"error": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"}]
        except BadRequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è {telegram_id}: {str(e)}")
            return [{"error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å"}]
        except ForbiddenError:
            logger.error(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è {telegram_id}")
            return [{"error": "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"}]
        except UnauthorizedError:
            logger.error("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π API —Ç–æ–∫–µ–Ω")
            return [{"error": "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ API"}]
        except ServerError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
            return [{"error": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞"}]
        except ApiError as e:
            logger.error(f"–û—à–∏–±–∫–∞ API: {str(e)}")
            return [{"error": f"–û—à–∏–±–∫–∞ API: {str(e)}"}]
        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)
            return [{"error": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}]

    async def get_subscription_by_uuid(self, subscription_uuid: str) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–¥–ø–∏—Å–∫–µ –ø–æ UUID
        :param subscription_uuid: UUID –ø–æ–¥–ø–∏—Å–∫–∏
        :return: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –∏–ª–∏ –æ—à–∏–±–∫–æ–π
        """
        try:
            if not subscription_uuid:
                logger.error("–ü—É—Å—Ç–æ–π UUID –ø–æ–¥–ø–∏—Å–∫–∏")
                return {"error": "–ù–µ —É–∫–∞–∑–∞–Ω UUID –ø–æ–¥–ø–∏—Å–∫–∏"}

            logger.debug(f"–ó–∞–ø—Ä–æ—Å –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ UUID: {subscription_uuid}")
            
            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ API
            response: UserResponseDto = await self.client.users.get_user_by_uuid(subscription_uuid)
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–≤–µ—Ç API
            subscription = await self._transform_user_response(response)
            
            logger.info(f"–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ {subscription_uuid}")
            return subscription

        except NotFoundError:
            logger.warning(f"–ü–æ–¥–ø–∏—Å–∫–∞ {subscription_uuid} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return {"error": "–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}
        except BadRequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è UUID {subscription_uuid}: {str(e)}")
            return {"error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å"}
        except ForbiddenError:
            logger.error(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è UUID {subscription_uuid}")
            return {"error": "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"}
        except UnauthorizedError:
            logger.error("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π API —Ç–æ–∫–µ–Ω")
            return {"error": "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ API"}
        except ServerError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
            return {"error": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞"}
        except ApiError as e:
            logger.error(f"–û—à–∏–±–∫–∞ API: {str(e)}")
            return {"error": f"–û—à–∏–±–∫–∞ API: {str(e)}"}
        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)
            return {"error": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}

    async def update_user(self, user_uuid: str, update_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ UUID
        :param user_uuid: UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        :param update_data: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        :return: –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—å —Å –æ—à–∏–±–∫–æ–π
        """
        try:
            if not user_uuid:
                logger.error("–ü—É—Å—Ç–æ–π UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                return {"error": "–ù–µ —É–∫–∞–∑–∞–Ω UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"}

            if not update_data:
                logger.error("–ü—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
                return {"error": "–ù–µ —É–∫–∞–∑–∞–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"}

            logger.debug(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å UUID {user_uuid}: {update_data}")

            # –§–æ—Ä–º–∏—Ä—É–µ–º DTO –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
            update_request = UpdateUserRequestDto(
                uuid=user_uuid,
                **update_data
            )

            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ API
            response: UserResponseDto = await self.client.users.update_user(user_uuid, update_request)

            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–≤–µ—Ç API
            updated_user = await self._transform_user_response(response)
            
            logger.info(f"–£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å UUID {user_uuid}")
            return updated_user

        except NotFoundError:
            logger.warning(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å UUID {user_uuid} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return {"error": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"}
        except BadRequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è UUID {user_uuid}: {str(e)}")
            return {"error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å"}
        except ForbiddenError:
            logger.error(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è UUID {user_uuid}")
            return {"error": "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"}
        except UnauthorizedError:
            logger.error("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π API —Ç–æ–∫–µ–Ω")
            return {"error": "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ API"}
        except ConflictError:
            logger.error(f"–ö–æ–Ω—Ñ–ª–∏–∫—Ç –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å UUID {user_uuid}")
            return {"error": "–ö–æ–Ω—Ñ–ª–∏–∫—Ç –¥–∞–Ω–Ω—ã—Ö"}
        except ServerError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
            return {"error": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞"}
        except ApiError as e:
            logger.error(f"–û—à–∏–±–∫–∞ API: {str(e)}")
            return {"error": f"–û—à–∏–±–∫–∞ API: {str(e)}"}
        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)
            return {"error": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}

    async def update_user_by_telegram_id(self, telegram_id: int, update_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID
        :param telegram_id: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram
        :param update_data: –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        :return: –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ —Å–ª–æ–≤–∞—Ä—å —Å –æ—à–∏–±–∫–æ–π
        """
        try:
            # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º UUID –ø–æ Telegram ID
            subscriptions = await self.get_user_by_telegram_id(telegram_id)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–¥–ø–∏—Å–∫–∏
            if not subscriptions or "error" in subscriptions[0]:
                error_msg = subscriptions[0].get("error", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                logger.warning(f"–ü–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è Telegram ID {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: {error_msg}")
                return {"error": error_msg}

            # –ë–µ—Ä–µ–º UUID –ø–µ—Ä–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–∏
            user_uuid = subscriptions[0]["uuid"]
            logger.debug(f"–ù–∞–π–¥–µ–Ω UUID {user_uuid} –¥–ª—è Telegram ID {telegram_id}")

            # –®–∞–≥ 2: –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            result = await self.update_user(user_uuid, update_data)
            return result

        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ Telegram ID {telegram_id}: {str(e)}", exc_info=True)
            return {"error": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}

    async def get_connected_devices(self, user_uuid: str) -> List[Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏.
        
        Args:
            user_uuid: UUID –ø–æ–¥–ø–∏—Å–∫–∏.
        
        Returns:
            List[Dict]: –°–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∏–ª–∏ –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–µ.
        """
        try:
            logger.debug(f"–ó–∞–ø—Ä–æ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid}")
            response: HWIDUserResponseDtoList = await self.client.hwid.get_hwid_user(user_uuid)
            devices = [
                {
                    "hwid": device.hwid,
                    "user_uuid": str(device.user_uuid),
                    "platform": device.platform,
                    "os_version": device.os_version,
                    "device_model": device.device_model,
                    "user_agent": device.user_agent,
                    "created_at": device.created_at,
                    "updated_at": device.updated_at
                }
                for device in response.devices
            ]
            logger.debug(f"–ü–æ–ª—É—á–µ–Ω–æ {len(devices)} —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid}")
            return devices
        except NotFoundError:
            logger.warning(f"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return []
        except BadRequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è {user_uuid}: {str(e)}")
            return []
        except ForbiddenError:
            logger.error(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è {user_uuid}")
            return []
        except UnauthorizedError:
            logger.error("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π API —Ç–æ–∫–µ–Ω")
            return []
        except ServerError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
            return []
        except ApiError as e:
            logger.error(f"–û—à–∏–±–∫–∞ API: {str(e)}")
            return []
        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –¥–ª—è {user_uuid}: {str(e)}", exc_info=True)
            return []

    async def remove_device(self, user_uuid: str, hwid: str) -> bool:
        """
        –£–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏–∑ –ø–æ–¥–ø–∏—Å–∫–∏.
        
        Args:
            user_uuid: UUID –ø–æ–¥–ø–∏—Å–∫–∏.
            hwid: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (HWID).
        
        Returns:
            bool: True –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º —É–¥–∞–ª–µ–Ω–∏–∏, False –ø—Ä–∏ –æ—à–∏–±–∫–µ.
        """
        try:
            logger.debug(f"–£–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ {hwid} –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid}")
            body = HWIDDeleteRequest(hwid=hwid, userUuid=UUID(user_uuid))
            response: HWIDUserResponseDtoList = await self.client.hwid.delete_hwid_to_user(body)
            logger.info(f"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ {hwid} —É–¥–∞–ª–µ–Ω–æ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid}")
            return True
        except NotFoundError:
            logger.warning(f"–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ {hwid} –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ {user_uuid} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return False
        except BadRequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ {hwid}: {str(e)}")
            return False
        except ForbiddenError:
            logger.error(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ {hwid}")
            return False
        except UnauthorizedError:
            logger.error("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π API —Ç–æ–∫–µ–Ω")
            return False
        except ServerError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
            return False
        except ApiError as e:
            logger.error(f"–û—à–∏–±–∫–∞ API: {str(e)}")
            return False
        except Exception as e:
            logger.critical(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ {hwid} –¥–ª—è {user_uuid}: {str(e)}", exc_info=True)
            return False

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
remnawave_service = RemnawaveService(
    base_url=os.getenv("REMNAWAVE_BASE_URL", "https://api.remnawave.com"),
    token=os.getenv("REMNAWAVE_TOKEN", "your_api_token_here")
)


--------------------------------------------------

